package exploitation

import (
	"0xRedisis/modules/core"
	"fmt"
	"strconv"
	"strings"
)

func Reconnaissance(client *core.RedisClient) {
	fmt.Printf("\n%s=== Redis Reconnaissance ===%s\n", core.ColorBlue, core.ColorNC)

	// Get server information
	fmt.Printf("%s[*]%s Gathering server information...\n", core.ColorBlue, core.ColorNC)
	getServerInfo(client)

	// Get memory usage
	fmt.Printf("\n%s[*]%s Checking memory usage...\n", core.ColorBlue, core.ColorNC)
	getMemoryInfo(client)

	// Get database information
	fmt.Printf("\n%s[*]%s Gathering database information...\n", core.ColorBlue, core.ColorNC)
	getDatabaseInfo(client)

	// Check for dangerous commands
	fmt.Printf("\n%s[*]%s Testing dangerous commands availability...\n", core.ColorBlue, core.ColorNC)
	checkDangerousCommands(client)

	// Get configuration
	fmt.Printf("\n%s[*]%s Getting configuration information...\n", core.ColorBlue, core.ColorNC)
	getConfigInfo(client)
}

func getServerInfo(client *core.RedisClient) {
	info, err := client.SendCommand("INFO", "server")
	if err != nil {
		fmt.Printf("%s[-]%s Failed to get server info: %s\n", core.ColorRed, core.ColorNC, err.Error())
		return
	}

	// Parse and display key information
	version := core.ExtractInfoValue(info, "redis_version")
	mode := core.ExtractInfoValue(info, "redis_mode")
	os := core.ExtractInfoValue(info, "os")
	arch := core.ExtractInfoValue(info, "arch_bits")
	process := core.ExtractInfoValue(info, "process_id")
	uptime := core.ExtractInfoValue(info, "uptime_in_seconds")

	fmt.Printf("%s[+]%s Redis Version: %s%s%s\n", core.ColorGreen, core.ColorNC, core.ColorYellow, version, core.ColorNC)
	fmt.Printf("%s[+]%s Redis Mode: %s%s%s\n", core.ColorGreen, core.ColorNC, core.ColorYellow, mode, core.ColorNC)
	fmt.Printf("%s[+]%s Operating System: %s%s%s\n", core.ColorGreen, core.ColorNC, core.ColorYellow, os, core.ColorNC)
	fmt.Printf("%s[+]%s Architecture: %s%s bits%s\n", core.ColorGreen, core.ColorNC, core.ColorYellow, arch, core.ColorNC)
	fmt.Printf("%s[+]%s Process ID: %s%s%s\n", core.ColorGreen, core.ColorNC, core.ColorYellow, process, core.ColorNC)

	if uptimeInt, err := strconv.Atoi(uptime); err == nil {
		uptimeHours := uptimeInt / 3600
		fmt.Printf("%s[+]%s Uptime: %s%d hours (%s seconds)%s\n",
			core.ColorGreen, core.ColorNC, core.ColorYellow, uptimeHours, uptime, core.ColorNC)
	}
}

func getMemoryInfo(client *core.RedisClient) {
	info, err := client.SendCommand("INFO", "memory")
	if err != nil {
		fmt.Printf("%s[-]%s Failed to get memory info: %s\n", core.ColorRed, core.ColorNC, err.Error())
		return
	}

	usedMemory := core.ExtractInfoValue(info, "used_memory_human")
	peakMemory := core.ExtractInfoValue(info, "used_memory_peak_human")
	totalSystem := core.ExtractInfoValue(info, "total_system_memory_human")

	fmt.Printf("%s[+]%s Used Memory: %s%s%s\n", core.ColorGreen, core.ColorNC, core.ColorYellow, usedMemory, core.ColorNC)
	fmt.Printf("%s[+]%s Peak Memory: %s%s%s\n", core.ColorGreen, core.ColorNC, core.ColorYellow, peakMemory, core.ColorNC)
	fmt.Printf("%s[+]%s Total System Memory: %s%s%s\n", core.ColorGreen, core.ColorNC, core.ColorYellow, totalSystem, core.ColorNC)
}

func getDatabaseInfo(client *core.RedisClient) {
	// Get keyspace info
	info, err := client.SendCommand("INFO", "keyspace")
	if err != nil {
		fmt.Printf("%s[-]%s Failed to get keyspace info: %s\n", core.ColorRed, core.ColorNC, err.Error())
		return
	}

	lines := strings.Split(info, "\n")
	dbCount := 0
	totalKeys := 0

	for _, line := range lines {
		line = strings.TrimSpace(line)
		if strings.HasPrefix(line, "db") {
			dbCount++
			// Extract number of keys from db info (format: db0:keys=X,expires=Y,avg_ttl=Z)
			if parts := strings.Split(line, "keys="); len(parts) > 1 {
				if keysPart := strings.Split(parts[1], ","); len(keysPart) > 0 {
					if keys, err := strconv.Atoi(keysPart[0]); err == nil {
						totalKeys += keys
						fmt.Printf("%s[+]%s Database %s: %s%d keys%s\n",
							core.ColorGreen, core.ColorNC, strings.Split(line, ":")[0], core.ColorYellow, keys, core.ColorNC)
					}
				}
			}
		}
	}

	fmt.Printf("%s[+]%s Total Databases: %s%d%s\n", core.ColorGreen, core.ColorNC, core.ColorYellow, dbCount, core.ColorNC)
	fmt.Printf("%s[+]%s Total Keys: %s%d%s\n", core.ColorGreen, core.ColorNC, core.ColorYellow, totalKeys, core.ColorNC)

	// Try to get some random keys
	if totalKeys > 0 {
		fmt.Printf("\n%s[*]%s Sampling some keys:\n", core.ColorBlue, core.ColorNC)
		keys, err := client.SendCommand("RANDOMKEY")
		if err == nil && !strings.Contains(keys, "nil") {
			cleanKey := strings.TrimSpace(strings.ReplaceAll(keys, "+", ""))
			fmt.Printf("%s[+]%s Sample key: %s%s%s\n", core.ColorGreen, core.ColorNC, core.ColorYellow, cleanKey, core.ColorNC)

			// Get key type
			keyType, err := client.SendCommand("TYPE", cleanKey)
			if err == nil {
				cleanType := strings.TrimSpace(strings.ReplaceAll(keyType, "+", ""))
				fmt.Printf("%s[+]%s Key type: %s%s%s\n", core.ColorGreen, core.ColorNC, core.ColorYellow, cleanType, core.ColorNC)
			}
		}
	}
}

func checkDangerousCommands(client *core.RedisClient) {
	dangerousCommands := []string{
		"FLUSHALL",
		"FLUSHDB",
		"CONFIG",
		"EVAL",
		"SCRIPT",
		"SHUTDOWN",
		"DEBUG",
		"SAVE",
		"BGSAVE",
	}

	availableCommands := []string{}

	for _, cmd := range dangerousCommands {
		// Test if command exists by sending it with invalid args and checking error
		_, err := client.SendCommand(cmd)
		if err != nil {
			// If we get a specific error (not connection error), command likely exists
			if !strings.Contains(err.Error(), "connection") &&
				!strings.Contains(err.Error(), "timeout") {
				availableCommands = append(availableCommands, cmd)
			}
		} else {
			availableCommands = append(availableCommands, cmd)
		}
	}

	if len(availableCommands) > 0 {
		fmt.Printf("%s[!]%s Dangerous commands available:\n", core.ColorYellow, core.ColorNC)
		for _, cmd := range availableCommands {
			fmt.Printf("%s[+]%s %s%s%s\n", core.ColorGreen, core.ColorNC, core.ColorYellow, cmd, core.ColorNC)
		}
	} else {
		fmt.Printf("%s[+]%s No dangerous commands detected (or restricted)\n", core.ColorGreen, core.ColorNC)
	}
}

func getConfigInfo(client *core.RedisClient) {
	// Try to get some configuration information
	configs := []string{
		"dir",
		"dbfilename",
		"save",
		"requirepass",
		"bind",
		"port",
	}

	fmt.Printf("%s[*]%s Configuration information:\n", core.ColorBlue, core.ColorNC)

	for _, configKey := range configs {
		config, err := client.SendCommand("CONFIG", "GET", configKey)
		if err != nil {
			continue
		}

		// Parse config response (array format in RESP)
		lines := strings.Split(config, "\n")
		var value string
		for i, line := range lines {
			if strings.TrimSpace(line) == configKey && i+1 < len(lines) {
				value = strings.TrimSpace(lines[i+1])
				break
			}
		}

		if value != "" {
			// Mask password if present
			if configKey == "requirepass" && value != "" {
				value = "***"
			}
			fmt.Printf("%s[+]%s %s: %s%s%s\n",
				core.ColorGreen, core.ColorNC, configKey, core.ColorYellow, value, core.ColorNC)
		}
	}
}
